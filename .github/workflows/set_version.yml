name: Create version for pull request tasks

on:
  pull_request:
    branches: [ main ]

  workflow_dispatch:

jobs:
  set-version:
    runs-on: ubuntu-latest
    steps:
      - name: checkout
        uses: actions/checkout@v2

      - uses: actions/setup-node@v2
        name: install packages
        with:
          node-version: 14
      - run: npm ci
      - run: npm install moment
      - run: npm install node-fetch

      - name: get commits list
        uses: actions/github-script@v4
        id: commits-list
        with:
          github-token: ${{secrets.TOKEN}}
          script: |
            const commits = await github.pulls.listCommits({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number,
            });
            const jira_matcher = /\d+-[A-Z]+(?!-?[a-zA-Z]{1,10})/g;
            const issues = commits.data.reduce((issues, item) => {
              const names = item.commit.message.split("").reverse().join("").match(jira_matcher);
              if (!names) {
                return issues;
              }
              names.forEach(res => {
                const id = res.split("").reverse().join("");
                if(issues.indexOf(id)===-1) {
                  issues.push(id)
                }
              })
              return issues;
            }, []);
            return JSON.stringify(issues);
          result-encoding: string

      - name: jira cooperation
        uses: actions/github-script@v4
        id: jira-version-set
        with:
          jira-token: ${{secrets.JIRA_TOKEN}}
          jira-user: ${{secrets.JIRA_USER}}
          jira-domain: 'tangem'
          release-version: 'test-3'
          project-name: 'MM'
          github-email: 'sidorovpav@yandex.ru'
          issues: ${{steps.commits-list.outputs.result}}
          script: |
            const issues = JSON.parse(core.getInput("issues", { required: true }));
            const domain = core.getInput("jira-domain", { required: true });
            const user = core.getInput("jira-user", { required: true });
            const token = core.getInput("jira-token", { required: true });
            const projectName = core.getInput("project-name", { required: true });
            const releaseVersion = core.getInput("release-version", { required: true });
            const githubEmail = core.getInput("github-email", { required: true });

            const fetch = require("node-fetch");
            const moment = require("moment");
            const connectJira = (domain, user, token, projectName) => {
              const AuthString = Buffer.from(`${user}:${token}`).toString('base64');
              async function getRequest(command){
            	const res = await fetch(
            	  `https://${domain}.atlassian.net/rest/api/3/${command}`,
            	  {
            		method: "GET",
            		headers: {
            		  "Accept": "application/json",
            		  "Authorization": `Basic ${AuthString}`,
            		},
            	  });
            	return res.json();
              }

              const setRequest = async (command, body, isUpdate = false) => {
            	const res = await fetch(`https://${domain}.atlassian.net/rest/api/3/${command}`,
            	  {
            		method: isUpdate ? "PUT" : "POST",
            		headers: {
            		  "Accept": "application/json",
                      "Authorization": `Basic ${AuthString}`,
                      "Content-Type": "application/json"
                    },
                    body,
                  });
                return isUpdate ? res : res.json();
              };

              const mapIssue = async ({ key, fields }) => {
                return {
                  uri: `https://${domain}.atlassian.net/browse/${key}`,
                  key,
                  issueTypeId: fields.issuetype.id,
                  summary: fields.summary,
                  existFixVersions: fields.fixVersions.length > 0
                };
              };

              const mapIssueType = (response) => {
                const types = new Map();
                response.forEach(item => {
                  const { untranslatedName: name} = item;
                  types.set(item.id, { name });
                });
                return types;
              }

              const getIssue = async (id) => mapIssue(await getRequest(`issue/${id}/?fields=issuetype,summary,fixVersions`));
              const getIssueType = async () => mapIssueType(await getRequest('issuetype'));
              const getProjectId = async () => {
                const response = await getRequest(`project/${projectName}`);
                return response.id;
              };
              const findProjectVersionByName = async (version) =>
                (await getRequest(`project/${projectName}/versions`)).find(item => item.name === version);

              const createVersion = async (projectId, version) =>
                await setRequest(`version`,
                `{
                  "archived": false,
                  "releaseDate": "${moment().format("YYYY-MM-DD")}",
                  "name": "${version}",
                  "projectId": ${projectId},
                  "released": true
                }`);

              const getOrCreateVersion = async (versionName) => {
                const version = await findProjectVersionByName(versionName);
                if (!version) {
                  const projectId = await getProjectId();
                  return await createVersion(projectId, versionName)
                }
                return version;
              };

              const issueSetVersion = async ({ key }, { id }) => {
                return setRequest(`issue/${key}`,
                  `{ "update": { "fixVersions": [ { "set": [ { "id": "${id}" } ] } ] } }`,
                  true
                )};

              const setVersionToIssues = async (version, issues) => {
                return await Promise.all([
                ...issues.map(async item => issueSetVersion(item, version))
                ]);
              };

              return {
                getIssues: async (arr) => {
                  const [types, ...issues] = await Promise.all([
                    getIssueType(),
                    ...arr.map(async item => getIssue(item))
                  ]);

                  const sortArray = ['Bug', 'Improvement', 'New feature'];

                  return issues
                    .map(item => {
                      return { ...item, issueType: types.get(item.issueTypeId).name };
                    })
                    .filter(item => {
                      return item.issueType.toLowerCase() !== 'bug' || !item.existFixVersions
                    })
                    .sort((a, b) => sortArray.indexOf(b.issueType) - sortArray.indexOf(a.issueType));
                },

                setVersionToIssues: async (versionName, issues) => {
                  const version = await getOrCreateVersion(versionName);
                  return setVersionToIssues(version, issues);
                },
              };
            };
            const jira = connectJira(domain, user, token, projectName);
            const jiraIssues = await jira.getIssues(issues);
            const commentText = jiraIssues
              .map(({ issueType, key, uri, summary }) => `<${issueType}>[${key}](${uri}) ${summary}`)
              .join('\r\n');

            await github.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: commentText,
            });

            await github.repos.createOrUpdateFileContents({
              owner: context.repo.owner,
              repo: context.repo.repo,
              path: `Version ${releaseVersion}.md`,
              message: `feat: Added Version ${releaseVersion}.md`,
              content: Buffer.from(commentText).toString('base64'),
              committer: {
                name: "Octokit Bot",
                email: githubEmail
              },
              author: {
                name: "Octokit Bot",
                email: githubEmail
              }
            });

            return await jira.setVersionToIssues(releaseVersion, jiraIssues);
